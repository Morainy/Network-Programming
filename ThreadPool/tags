!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BUFFER_SIZE	cgiServer.cpp	/^	static const int BUFFER_SIZE = 1024;$/;"	m	class:cgi_conn	file:
CONTROL_LEN	passfd.cpp	/^static const int CONTROL_LEN = CMSG_LEN(sizeof(int));$/;"	v	file:
LOCKER_H	locker.h	19;"	d
MAX_EVENT_NUMBER	processpool.h	/^		static const int MAX_EVENT_NUMBER = 10000;$/;"	m	class:processpool
MAX_PROCESS_NUMBER	processpool.h	/^		static const int MAX_PROCESS_NUMBER = 16;$/;"	m	class:processpool
PROCESSPOOL_H	processpool.h	19;"	d
THREADPOOL_H	threadpool.h	19;"	d
USER_PRE_PROCESS	processpool.h	/^		static const int USER_PRE_PROCESS = 65536;$/;"	m	class:processpool
addfd	processpool.h	/^static void addfd(int epollfd , int fd)$/;"	f
addsig	processpool.h	/^static void addsig(int sig , void(*handler)(int) , bool restart = true)$/;"	f
append	threadpool.h	/^ bool threadpool<T>::append(T* request)$/;"	f	class:threadpool
cgi_conn	cgiServer.cpp	/^	cgi_conn(){}$/;"	f	class:cgi_conn
cgi_conn	cgiServer.cpp	/^class cgi_conn{$/;"	c	file:
cond	locker.h	/^		cond()$/;"	f	class:cond
cond	locker.h	/^class cond$/;"	c
create	processpool.h	/^		static processpool<T>* create(int listenfd , int processnumber = 8)$/;"	f	class:processpool
init	cgiServer.cpp	/^	void init(int epollfd , int sockfd , const sockaddr_in& client_addr)$/;"	f	class:cgi_conn
lock	locker.h	/^		bool lock()$/;"	f	class:locker
locker	locker.h	/^		locker()$/;"	f	class:locker
locker	locker.h	/^class locker$/;"	c
m_address	cgiServer.cpp	/^	sockaddr_in m_address;$/;"	m	class:cgi_conn	file:
m_buf	cgiServer.cpp	/^	char m_buf[BUFFER_SIZE];$/;"	m	class:cgi_conn	file:
m_cond	locker.h	/^		pthread_cond_t m_cond;$/;"	m	class:cond
m_epollfd	cgiServer.cpp	/^	static int m_epollfd;$/;"	m	class:cgi_conn	file:
m_epollfd	processpool.h	/^		int m_epollfd;$/;"	m	class:processpool
m_idx	processpool.h	/^		int m_idx;$/;"	m	class:processpool
m_instance	processpool.h	/^		static processpool<T>* m_instance;$/;"	m	class:processpool
m_instance	processpool.h	/^processpool<T>* processpool<T>::m_instance = NULL;$/;"	m	class:processpool
m_listenfd	processpool.h	/^		int m_listenfd;$/;"	m	class:processpool
m_max_requests	threadpool.h	/^ 	int m_max_requests;$/;"	m	class:threadpool
m_mutex	locker.h	/^		pthread_mutex_t m_mutex;$/;"	m	class:cond
m_mutex	locker.h	/^		pthread_mutex_t m_mutex;$/;"	m	class:locker
m_pid	processpool.h	/^		pid_t m_pid;$/;"	m	class:process
m_pipefd	processpool.h	/^		int m_pipefd[2];$/;"	m	class:process
m_process_number	processpool.h	/^		int m_process_number;$/;"	m	class:processpool
m_queuelocker	threadpool.h	/^ 	locker m_queuelocker;$/;"	m	class:threadpool
m_queuestat	threadpool.h	/^ 	sem m_queuestat;$/;"	m	class:threadpool
m_read_idx	cgiServer.cpp	/^	int m_read_idx;$/;"	m	class:cgi_conn	file:
m_sem	locker.h	/^	sem_t m_sem;$/;"	m	class:sem
m_sockfd	cgiServer.cpp	/^	int m_sockfd;$/;"	m	class:cgi_conn	file:
m_stop	processpool.h	/^		int m_stop;$/;"	m	class:processpool
m_stop	threadpool.h	/^ 	bool m_stop;$/;"	m	class:threadpool
m_sub_process	processpool.h	/^		process* m_sub_process;$/;"	m	class:processpool
m_thread_number	threadpool.h	/^ 	int m_thread_number;$/;"	m	class:threadpool
m_threads	threadpool.h	/^ 	pthread_t* m_threads;$/;"	m	class:threadpool
m_workqueue	threadpool.h	/^ 	std::list<T*> m_workqueue;$/;"	m	class:threadpool
main	cgiServer.cpp	/^ int main(int argc, char const *argv[])$/;"	f
main	passfd.cpp	/^int main(int argc, char const *argv[])$/;"	f
post	locker.h	/^	bool post()$/;"	f	class:sem
process	cgiServer.cpp	/^	void process()$/;"	f	class:cgi_conn
process	processpool.h	/^		process():m_pid(-1){}$/;"	f	class:process
process	processpool.h	/^class process{$/;"	c
processpool	processpool.h	/^class processpool{$/;"	c
processpool	processpool.h	/^processpool<T>::processpool(int listenfd , int process_number):m_listenfd(listenfd) , m_process_number(process_number) , m_idx(-1),m_stop(false)$/;"	f	class:processpool
recv_fd	passfd.cpp	/^int recv_fd(int fd)$/;"	f
removefd	processpool.h	/^static void removefd(int epollfd , int fd)$/;"	f
run	processpool.h	/^void processpool<T>::run()$/;"	f	class:processpool
run	threadpool.h	/^ void threadpool<T>::run()$/;"	f	class:threadpool
run_child	processpool.h	/^void processpool<T>::run_child()$/;"	f	class:processpool
run_parent	processpool.h	/^void processpool<T>::run_parent()$/;"	f	class:processpool
sem	locker.h	/^	sem()$/;"	f	class:sem
sem	locker.h	/^class sem{$/;"	c
send_fd	passfd.cpp	/^void send_fd(int fd , int fd_to_send)$/;"	f
setnonblocking	processpool.h	/^static int setnonblocking(int fd)$/;"	f
setup_sig_pipe	processpool.h	/^void processpool<T>::setup_sig_pipe()$/;"	f	class:processpool
sig_handler	processpool.h	/^static void sig_handler(int sig)$/;"	f
sig_pipefd	processpool.h	/^static int sig_pipefd[2];$/;"	v
signal	locker.h	/^		bool signal()$/;"	f	class:cond
threadpool	threadpool.h	/^ class threadpool$/;"	c
threadpool	threadpool.h	/^ threadpool<T>::threadpool(int thread_number , int max_requests):m_thread_number(thread_number),$/;"	f	class:threadpool
unlock	locker.h	/^		bool unlock()$/;"	f	class:locker
wait	locker.h	/^		bool wait()$/;"	f	class:cond
wait	locker.h	/^	bool wait()$/;"	f	class:sem
worker	threadpool.h	/^ void* threadpool<T>::worker(void* arg)$/;"	f	class:threadpool
~cgi_conn	cgiServer.cpp	/^	~cgi_conn(){}$/;"	f	class:cgi_conn
~cond	locker.h	/^		~cond()$/;"	f	class:cond
~locker	locker.h	/^		~locker()$/;"	f	class:locker
~processpool	processpool.h	/^		~processpool()$/;"	f	class:processpool
~sem	locker.h	/^	~sem()$/;"	f	class:sem
~threadpool	threadpool.h	/^ threadpool<T>::~threadpool()$/;"	f	class:threadpool
